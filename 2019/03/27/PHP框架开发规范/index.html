<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Tgroup"><link rel="alternative" href="/atom.xml" title="Tgroup" type="application/atom+xml"><link rel="icon" href="/favicon.png"><title>PHP框架开发规范 - Tgroup</title><link rel="stylesheet" href="/tgroup/css/main.css"><link rel="stylesheet" href="/tgroup/js/fancybox/jquery.fancybox.min.css"><!--[if lt IE 9]><script>(function(a,b){a="abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video".split(" ");for(b=a.length-1;b>=0;b--)document.createElement(a[b])})()</script><![endif]--><script src="/tgroup/js/jquery-3.1.1.min.js"></script><script src="/tgroup/js/fancybox/jquery.fancybox.min.js"></script></head><body style="opacity:0"><header class="head"><h1 class="head-title u-fl"><a href="/tgroup/">Tgroup</a></h1><nav class="head-nav u-fr"><ul class="head-nav__list"><li class="head-nav__item"><a class="head-nav__link" href="/tgroup/archives">Catalog/（目录）</a></li></ul></nav></header><main class="main"><article class="post"><header class="post__head"><time class="post__time" datetime="2019-03-27T10:49:54.000Z">March 27, 2019</time><h1 class="post__title"><a href="/tgroup/2019/03/27/PHP框架开发规范/">PHP框架开发规范</a></h1><div class="post__main echo"><h2 id="1-选择："><a href="#1-选择：" class="headerlink" title="1. 选择："></a>1. 选择：</h2><p>在没有用户要求及特殊性能要求情况下，我们首先选择Lavarel 框架，版本5.5.X 及以上。如果有极限性能要求，我们选择 Phalcon 作为首选的开发框架，作为C的框架，性能足够强悍，并经过了极客学员核心coreapi的项目检验。</p>
<h2 id="2-lavarel-框架使用规范："><a href="#2-lavarel-框架使用规范：" class="headerlink" title="2. lavarel 框架使用规范："></a>2. lavarel 框架使用规范：</h2><h3 id="2-1-目录结构-以Laravel5-6为例"><a href="#2-1-目录结构-以Laravel5-6为例" class="headerlink" title="2.1 目录结构 - 以Laravel5.6为例"></a>2.1 目录结构 - 以Laravel5.6为例</h3><p><strong>=&gt; App目录</strong><br>app 目录包含了应用的核心代码，你为应用编写的代码绝大多数也会放到这里。（注意不是框架的核心代码，框架的核心代码在 /vendor/laravel/framework 里面）。</p>
<p><strong>=&gt; Bootstrap目录</strong><br>bootstrap 目录包含了少许文件，用于框架的启动和自动载入配置，还有一个 cache 文件夹，里面包含了框架为提升性能所生成的文件，如路由和服务缓存文件；</p>
<p><strong>=&gt; Config目录</strong><br>config 目录包含了应用所有的配置文件，建议通读一遍这些配置文件以便熟悉 Laravel 所有默认配置项；</p>
<p><strong>=&gt; Database目录</strong><br>database 目录包含了数据库迁移文件及填充文件，如果有使用 SQLite 的话，你还可以将其作为 SQLite 数据库存放目录；</p>
<p><strong>=&gt; Public目录</strong><br>public 目录包含了应用入口文件 index.php 和前端资源文件（图片、JavaScript、CSS等），该目录也是 Apache 或 Nginx 等 Web 服务器所指向的应用根目录，这样做的好处是隔离了应用核心文件直接暴露于 Web 根目录之下，如果权限系统没做好或服务器配置有漏洞的话，很可能导致应用敏感文件被黑客窃取，进而对网站安全造成威胁；</p>
<p><strong>=&gt; Resources目录</strong><br>resources 目录包含了应用视图文件和未编译的原生前端资源文件（LESS、SASS、JavaScript），以及本地化语言文件；</p>
<p><strong>=&gt; Routes目录</strong><br>routes 目录包含了应用定义的所有路由。Laravel 默认提供了四个路由文件用于给不同的入口使用：web.php、api.php、 console.php 和 channels.php。<br>web.php 文件包含的路由都位于 RouteServiceProvider 所定义的 web 中间件组约束之内，因而支持 Session、CSRF 保护以及 Cookie 加密功能，如果应用无需提供无状态的、RESTful 风格的 API，那么路由基本上都要定义在 web.php 文件中。<br>api.php 文件包含的路由位于 api 中间件组约束之内，支持频率限制功能，这些路由是无状态的，所以请求通过这些路由进入应用需要通过 token 进行认证并且不能访问 Session 状态。<br>console.php 文件用于定义所有基于闭包的控制台命令，每个闭包都被绑定到一个控制台命令并且允许与命令行 IO 方法进行交互，尽管这个文件并不定义 HTTP 路由，但是它定义了基于控制台的应用入口（路由）。<br>channels.php 文件用于注册应用支持的所有事件广播频道。</p>
<p><strong>=&gt; Storage目录</strong><br>storage 目录包含了编译后的 Blade 模板、基于文件的 Session、文件缓存，以及其它由框架生成的文件，该目录被细分为成 app、framework 和 logs 子目录，app 目录用于存放应用生成的文件，framework 目录用于存放框架生成的文件和缓存，最后，logs 目录存放的是应用的日志文件。<br>storage/app/public 目录用于存储用户生成的文件，比如可以被公开访问的用户头像，要达到被 Web 用户访问的目的，你还需要在 public （应用根目录下的 public 目录）目录下生成一个软连接 storage 指向这个目录。你可以通过 php artisan storage:link 命令生成这个软链接。</p>
<p><strong>=&gt; Tests目录</strong><br>tests 目录包含自动化测试文件，其中默认已经提供了一个开箱即用的<a href="https://phpunit.de/" target="_blank" rel="noopener">PHPUnit</a> 示例；每一个测试类都要以 Test 开头，你可以通过 phpunit 或 php vendor/bin/phpunit 命令来运行测试。</p>
<p><strong>=&gt; Vendor目录</strong><br>vendor 目录包含了应用所有通过 <a href="https://getcomposer.org/" target="_blank" rel="noopener">Composer</a> 加载的依赖。</p>
<h3 id="2-2-特别说明：关于Models"><a href="#2-2-特别说明：关于Models" class="headerlink" title="2.2 特别说明：关于Models"></a>2.2 特别说明：关于Models</h3><p>Laravel并没有指定的Models目录，是因为模型层对不同的人有不同的定义。有些开发者认为应用的模型指的是业务逻辑，另外一些人则认为模型指的是与关联数据库的交互。</p>
<p>我个人给出的建议是：models 目录用于存放与数据库交互的模型类，而业务逻辑应该放到 services 目录之下。所以建议在生成模型类的时候指定生成到 app/Models 目录下：<br>如下面的例子所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:model Models/Test</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-生命周期"><a href="#2-3-生命周期" class="headerlink" title="2.3 生命周期"></a>2.3 生命周期</h3><p><strong>第一件事</strong><br>Laravel 应用的所有请求入口都是 public/index.php 文件，所有请求都会被 web 服务器（Apache/Nginx）导向这个文件。 index.php 文件包含的代码并不多，但是，这里是加载框架其它部分的起点。<br>index.php 文件载入 Composer 生成的自动加载设置，然后从 bootstrap/app.php 脚本获取 Laravel 应用实例，Laravel 的第一个动作就是创建<a href="http://laravelacademy.org/post/8695.html" target="_blank" rel="noopener">服务容器</a>实例。</p>
<p><strong>HTTP/Console 内核</strong><br>接下来，请求被发送到 HTTP 内核或 Console 内核（分别用于处理 Web 请求和 Artisan 命令），这取决于进入应用的请求类型。这两个内核是所有请求都要经过的中央处理器，现在，就让我们聚焦在位于 app/Http/Kernel.php 的 HTTP 内核。<br>HTTP 内核继承自 Illuminate\Foundation\Http\Kernel 类，该类定义了一个 bootstrappers 数组，这个数组中的类在请求被执行前运行，这些 bootstrappers 配置了错误处理、日志、<a href="http://laravelacademy.org/post/8650.html#toc_5" target="_blank" rel="noopener">检测应用环境</a>以及其它在请求被处理前需要执行的任务。<br>HTTP 内核还定义了一系列所有请求在处理前需要经过的 HTTP <a href="http://laravelacademy.org/post/7812.html" target="_blank" rel="noopener">中间件</a>，这些中间件处理 <a href="http://laravelacademy.org/post/7954.html" target="_blank" rel="noopener">HTTP 会话</a>的读写、判断应用是否处于维护模式、验证 <a href="http://laravelacademy.org/post/7820.html" target="_blank" rel="noopener">CSRF 令牌</a>等等。<br>HTTP 内核的 handle 方法签名相当简单：获取一个 Request，返回一个 Response，可以把该内核想象作一个代表整个应用的大黑盒子，输入 HTTP 请求，返回 HTTP 响应。</p>
<p><strong>服务提供者</strong><br>内核启动过程中最重要的动作之一就是为应用载入<a href="http://laravelacademy.org/post/8697.html" target="_blank" rel="noopener">服务提供者</a>，应用的所有服务提供者都被配置在 config/app.php配置文件的 providers 数组中。首先，所有提供者的 register 方法被调用，然后，所有提供者被注册之后，boot 方法被调用。<br>服务提供者负责启动框架的所有各种各样的组件，比如数据库、队列、验证器，以及路由组件等，正是因为他们启动并配置了框架提供的所有特性，所以服务提供者是整个 Laravel 启动过程中最重要的部分。</p>
<p><strong>分发请求</strong><br>一旦应用被启动并且所有的服务提供者被注册，Request 将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。</p>
<h3 id="2-3-路由规则"><a href="#2-3-路由规则" class="headerlink" title="2.3 路由规则"></a>2.3 路由规则</h3><p>配置目录：routes目录。</p>
<p>1）基本路由：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 1、get路由</span><br><span class="line">// 访问domain/hello，指向hello模板</span><br><span class="line">Route::get(&apos;/hello&apos;, function () &#123;</span><br><span class="line">    return view(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 2、post路由</span><br><span class="line">// 访问domain/post，指向hello模板</span><br><span class="line">Route::post(&apos;/post&apos;, function () &#123;</span><br><span class="line">    return view(&apos;hello&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 3、混合路由，get和post都可以。访问[域名/test]即可请求 </span><br><span class="line">Route::match([&apos;get&apos;,&apos;post&apos;], &apos;test&apos;, function () &#123;</span><br><span class="line">    return &apos;哈哈哈哈哈&apos;; </span><br><span class="line">&#125;); </span><br><span class="line"></span><br><span class="line">// 4、任意路由，所有请求方式都可以。[域名/hello]即可访问 </span><br><span class="line">Route::any(&apos;/hello&apos;,function()&#123; </span><br><span class="line">    return &quot;Hello Laravel!&quot;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>2）路由关联控制器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 访问domain/member/info，指向Member控制器下的info方法</span><br><span class="line">Route::get(&apos;/member/info&apos;,&apos;MemberController@info&apos;);</span><br></pre></td></tr></table></figure></p>
<p>3）资源路由（常用）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Route::resource(&apos;users&apos;, &apos;UsersController&apos;);</span><br></pre></td></tr></table></figure></p>
<p>以上资源路由相当于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Route::get(&apos;/users&apos;, &apos;UsersController@index&apos;)-&gt;name(&apos;users.index&apos;);</span><br><span class="line">Route::get(&apos;/users/&#123;user&#125;&apos;, &apos;UsersController@show&apos;)-&gt;name(&apos;users.show&apos;);</span><br><span class="line">Route::get(&apos;/users/create&apos;, &apos;UsersController@create&apos;)-&gt;name(&apos;users.create&apos;);</span><br><span class="line">Route::post(&apos;/users&apos;, &apos;UsersController@store&apos;)-&gt;name(&apos;users.store&apos;);</span><br><span class="line">Route::get(&apos;/users/&#123;user&#125;/edit&apos;, &apos;UsersController@edit&apos;)-&gt;name(&apos;users.edit&apos;);</span><br><span class="line">Route::patch(&apos;/users/&#123;user&#125;&apos;, &apos;UsersController@update&apos;)-&gt;name(&apos;users.update&apos;);</span><br><span class="line">Route::delete(&apos;/users/&#123;user&#125;&apos;, &apos;UsersController@destroy&apos;)-&gt;name(&apos;users.destroy&apos;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>我们一般采用资源路由。</p>
</blockquote>
<h2 id="3-数据库操作"><a href="#3-数据库操作" class="headerlink" title="3 数据库操作"></a>3 数据库操作</h2><h3 id="3-1-模型："><a href="#3-1-模型：" class="headerlink" title="3.1 模型："></a>3.1 模型：</h3><p>定义：models 我们认为它的作用应该是与数据库交互，并不做业务逻辑的处理。所以，我们的项目中建议把业务逻辑新建一个services进行处理。<br>模型设计原则一：Eloquent ORM每个类对应一个数据表名，模型类应与数据表名称相同，数据表名称采用小写下划线，数据库类名采用大写驼峰法。<br>如表名：user，则数据库类名称应该叫做User。<br>当表名出现下划线，如user_type，那么类名应该叫做UserType即可。Eloquent ORM模型会自动对应上去。<br>模型设计原则二：模型的名称应与数据表名称一致，并且主键都设置为”id”，这样无需在模型里面设置主键和表名了</p>
<h3 id="3-2-数据库操作："><a href="#3-2-数据库操作：" class="headerlink" title="3.2 数据库操作："></a>3.2 数据库操作：</h3><p>说明：Laravel里面可以使用原生查询、查询构造器查询和Eloquent ORM查询，这里我们只介绍简单介绍查询构造器和Eloquent ORM的基本操作：</p>
<p>3.2.1 查询构造器的使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 增 - 成功返回true</span><br><span class="line">$bool = DB::table(&apos;students&apos;)-&gt;insert([</span><br><span class="line">    &apos;name&apos; =&gt; &apos;linfeng&apos;,</span><br><span class="line">    &apos;age&apos; =&gt; &apos;22&apos;,</span><br><span class="line">]);</span><br><span class="line">// 更新数据</span><br><span class="line">$bool = DB::table(&apos;students&apos;)-&gt;where([&apos;id&apos;=&gt;2])-&gt;update([</span><br><span class="line">    &apos;age&apos; =&gt; 14,</span><br><span class="line">]);</span><br><span class="line">// 删除</span><br><span class="line">DB::table(&apos;students&apos;)-&gt;where([&apos;id&apos;=&gt;10]);</span><br><span class="line">// get() - 查询数据</span><br><span class="line">$students = DB::table(&apos;students&apos;)-&gt;get();</span><br><span class="line"></span><br><span class="line">// first() - 查询单条数据</span><br><span class="line">$students = DB::table(&apos;students&apos;)-&gt;orderBy(&apos;id&apos;,&apos;desc&apos;)-&gt;first();</span><br></pre></td></tr></table></figure></p>
<p>3.2.2 Eloquent ORM：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//all()</span><br><span class="line">$students=Student::all();</span><br><span class="line">//find();</span><br><span class="line">$student=Student::find(1001);</span><br><span class="line">//findOrFail()</span><br><span class="line">$student=Student::findOrFail(1008);</span><br><span class="line"></span><br><span class="line">//查询构造器在ORM中的使用：</span><br><span class="line">$students=Student::get();</span><br><span class="line">//first()</span><br><span class="line">$students = Student::where(&apos;id&apos;,&apos;&gt;&apos;,&apos;1001&apos;)</span><br><span class="line">-&gt;orderBy(&apos;age&apos;,&apos;desc&apos;)</span><br><span class="line">-&gt;first();</span><br><span class="line">//chunk()</span><br><span class="line">Student::chunk(2,function ($students)&#123;</span><br><span class="line">    var_dump($students);</span><br><span class="line">&#125;);</span><br><span class="line">//查询构造器中的聚合函数：</span><br><span class="line">//count</span><br><span class="line">$num=Student::count();</span><br><span class="line">//max()</span><br><span class="line">$max=Student::where(&apos;id&apos;,&apos;&gt;&apos;,1001)-&gt;max(&apos;age&apos;);</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>请注意，查询构造器返回的是一个数组，而ORM返回的则是一个对象。更多的使用方法请查看官方手册。</p>
</blockquote>
<h3 id="3-3-关于数据库的命名"><a href="#3-3-关于数据库的命名" class="headerlink" title="3.3 关于数据库的命名"></a>3.3 关于数据库的命名</h3><p>为提升开发效率，配合 Laravel 的 ORM，数据表的名称采用复数：<br>例子如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>—— 请注意，以上的例子并没有指定连接到哪张表，但是在默认的情况下，会连接到数据库的 users表。<br>如果是 UserType 呢？ORM 会自动连接到 user_types表格</p>
<p>当然，某些特殊情况下（我也不知道是什么特殊情况），可能需要通过指定连接的是哪张表格。如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">namespace App;</span><br><span class="line"></span><br><span class="line">use Illuminate\Database\Eloquent\Model;</span><br><span class="line"></span><br><span class="line">class User extends Model</span><br><span class="line">&#123;</span><br><span class="line">    //</span><br><span class="line">    protected $table = &apos;user_type&apos;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-一些概念介绍"><a href="#4-一些概念介绍" class="headerlink" title="4 一些概念介绍"></a>4 一些概念介绍</h2><h3 id="4-1-服务容器"><a href="#4-1-服务容器" class="headerlink" title="4.1 服务容器"></a>4.1 服务容器</h3><p>Laravel 服务容器是一个用于管理类依赖和执行依赖注入的强大工具。依赖注入听上去很花哨，其实质是通过构造函数或者某些情况下通过 setter 方法将类依赖注入到类中。<br>文档：<a href="https://laravelacademy.org/post/8695.html" target="_blank" rel="noopener">https://laravelacademy.org/post/8695.html</a></p>
<h3 id="4-2-服务提供者"><a href="#4-2-服务提供者" class="headerlink" title="4.2 服务提供者"></a>4.2 服务提供者</h3><p>服务提供者是 Laravel 应用启动的中心，你自己的应用以及所有 Laravel 的核心服务都是通过服务提供者启动。<br>但是，我们所谓的“启动”指的是什么？通常，这意味着注册服务，包括注册服务容器绑定、事件监听器、中间件甚至路由。服务提供者是应用配置的中心。<br>如果你打开 Laravel 自带的 config/app.php 文件，将会看到一个 providers 数组，这里就是应用所要加载的所有服务提供者类，当然，其中很多是延迟加载的，也就是说不是每次请求都会被加载，只有真的用到它们的时候才会加载。<br>文档：<a href="https://laravelacademy.org/post/8697.html" target="_blank" rel="noopener">https://laravelacademy.org/post/8697.html</a></p>
<h3 id="4-3-门面Facades"><a href="#4-3-门面Facades" class="headerlink" title="4.3 门面Facades"></a>4.3 门面Facades</h3><p>门面为应用<a href="http://laravelacademy.org/post/8695.html" target="_blank" rel="noopener">服务容器</a>中的绑定类提供了一个“静态”接口。Laravel 内置了很多门面，你可能在不知道的情况下正在使用它们。Laravel 的门面作为服务容器中底层类的“静态代理”，相比于传统静态方法，在维护时能够提供更加易于测试、更加灵活、简明优雅的语法。<br>文档：<a href="https://laravelacademy.org/post/8708.html" target="_blank" rel="noopener">https://laravelacademy.org/post/8708.html</a></p>
<h3 id="4-4-契约"><a href="#4-4-契约" class="headerlink" title="4.4 契约"></a>4.4 契约</h3><p>Laravel 中的契约是指框架提供的一系列定义核心服务的接口。 例如，Illuminate\Contracts\Queue\Queue 契约定义了队列任务需要实现的方法，Illuminate\Contracts\Mail\Mailer 契约定义了发送邮件所需要实现的方法。<br>每一个契约都有框架提供的相应实现。例如，Laravel 为队列提供了多个驱动的实现，邮件则由 <a href="http://swiftmailer.org/" target="_blank" rel="noopener">SwiftMailer</a> 驱动实现 。<br>所有 Laravel 契约都有其<a href="https://github.com/illuminate/contracts">对应的GitHub库</a>，这为所有有效的契约提供了快速入门指南，同时也可以作为独立、解耦的包被包开发者使用。<br><a href="https://laravelacademy.org/post/8710.html" target="_blank" rel="noopener">https://laravelacademy.org/post/8710.html</a></p>
<h2 id="5-一些常用命令："><a href="#5-一些常用命令：" class="headerlink" title="5 一些常用命令："></a>5 一些常用命令：</h2><p>1）composer安装laravel：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 安装最新稳定版</span><br><span class="line">composer create-project --prefer-dist laravel/laravel laravel</span><br><span class="line">// 指定安装5.3.*版本</span><br><span class="line">composer create-project laravel/laravel --prefer-dist laravel &quot;5.6.*&quot;</span><br></pre></td></tr></table></figure></p>
<p>2）显示版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan –version</span><br></pre></td></tr></table></figure></p>
<p>3）创建控制器 - 在 app/controllers 目录下生成一个名为 控制器名.php 的控制器文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan controller:make 控制器名</span><br></pre></td></tr></table></figure></p>
<p>4）创建模型：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 创建模型并创建新迁移</span><br><span class="line">php artisan make:model User --migration</span><br></pre></td></tr></table></figure></p>
<p>5）清除应用程序缓存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan cache:clear</span><br></pre></td></tr></table></figure></p>
<p>6）开启Auth用户功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php artisan make:auth</span><br></pre></td></tr></table></figure></p>
<h2 id="6-RESTful风格和常用状态码："><a href="#6-RESTful风格和常用状态码：" class="headerlink" title="6 RESTful风格和常用状态码："></a>6 RESTful风格和常用状态码：</h2><h3 id="6-1-路由地址定义："><a href="#6-1-路由地址定义：" class="headerlink" title="6.1 路由地址定义："></a>6.1 路由地址定义：</h3><table>
<thead>
<tr>
<th style="text-align:left">方法</th>
<th style="text-align:left">请求路径</th>
<th>方法/动作</th>
<th>路由名称</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">/users</td>
<td>index</td>
<td>users.index</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">/users/create</td>
<td>create</td>
<td>users.create</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">/users</td>
<td>store</td>
<td>users.store</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">/users/{id}</td>
<td>show</td>
<td>users.show</td>
</tr>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">/users/{id}/edit</td>
<td>edit</td>
<td>users.edit</td>
</tr>
<tr>
<td style="text-align:left">PUT/PATCH</td>
<td style="text-align:left">/users/{id}</td>
<td>update</td>
<td>users.update</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">/users/{id}</td>
<td>destroy</td>
<td>users.destroy</td>
</tr>
</tbody>
</table>
<h3 id="6-2-常用状态码"><a href="#6-2-常用状态码" class="headerlink" title="6.2 常用状态码"></a>6.2 常用状态码</h3><p><strong>200 OK - 对成功的 GET、PUT、PATCH 或 DELETE 操作进行响应。也可以被用在不创建新资源的 </strong><br>POST 操作上<br><strong>201 Created - 对创建新资源的 POST 操作进行响应。应该带着指向新资源地址的 Location 头</strong><br>202 Accepted - 服务器接受了请求，但是还未处理，响应中应该包含相应的指示信息，告诉客户端该去哪里查询关于本次请求的信息<br>204 No Content - 对不会返回响应体的成功请求进行响应（比如 DELETE 请求）<br>304 Not Modified - HTTP缓存header生效的时候用<br>400 Bad Request - 请求异常，比如请求中的body无法解析<br><strong>401 Unauthorized - 没有进行认证或者认证非法</strong><br><strong>403 Forbidden - 服务器已经理解请求，但是拒绝执行它</strong><br><strong>404 Not Found - 请求一个不存在的资源</strong><br><strong>405 Method Not Allowed - 所请求的 HTTP 方法不允许当前认证用户访问</strong><br>410 Gone - 表示当前请求的资源不再可用。当调用老版本 API 的时候很有用<br>415 Unsupported Media Type - 如果请求中的内容类型是错误的<br>422 Unprocessable Entity - 用来表示校验错误<br>429 Too Many Requests - 由于请求频次达到上限而被拒绝访问</p>
<h2 id="7-一些开发中书写规范"><a href="#7-一些开发中书写规范" class="headerlink" title="7 一些开发中书写规范"></a>7 一些开发中书写规范</h2><h3 id="7-1-编码规范"><a href="#7-1-编码规范" class="headerlink" title="7.1 编码规范"></a>7.1 编码规范</h3><p>1）目录命名：文件夹名称<strong>必须</strong>符合CamelCase式的大写字母开头驼峰命名规范。<br>2）文件：纯PHP代码文件<strong>必须</strong>省略最后的 ?&gt; 结束标签。<br>3）行的长度<strong>一定</strong>限制在140个字符以内。<br>4）非空行后<strong>一定</strong>不能有多余的空格符。<br>5）每行<strong>一定</strong>不能存在多于一条语句。<br>6）适当空行<strong>可以</strong>使得阅读代码更加方便以及有助于代码的分块（但注意不能滥用空行）。<br>7）代码<strong>必须</strong>使用4个空格符的缩进，<strong>一定不能</strong>用 tab键 。<br>8）PHP所有<strong>关键字**</strong>必须<strong>全部小写。常量 </strong>true<strong>、</strong>false<strong>和 </strong>null<strong>**必须</strong>全部小写。<br>9）<strong>namespace </strong>声明后<strong>必须</strong>插入一个空白行。所有<strong>use**</strong>必须<strong>在</strong>namespace <strong>后声明。每条</strong>use<strong>声明语句</strong>必须<strong>只有一个</strong>use<strong>关键词。</strong>use <strong>声明语句块后</strong>必须**要有一个空白行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">namespace VendorgiPackage;</span><br><span class="line"></span><br><span class="line">use FooClass;</span><br><span class="line">use BarClass as Bar;</span><br><span class="line">use OtherVendorgiOtherPackage\BazClass;</span><br><span class="line"></span><br><span class="line">class ClassName</span><br><span class="line">&#123;</span><br><span class="line">    // constants, properties, methods</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-2-类、属性和方法"><a href="#7-2-类、属性和方法" class="headerlink" title="7.2 类、属性和方法"></a>7.2 类、属性和方法</h3><p>类的命名<strong>必须</strong>遵循大<strong>写字母</strong>开头的驼峰式命名规范：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class UserType </span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>类的常量中所有字母都<strong>必须</strong>大写，词间以<strong>下划线分隔</strong>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">USER_TYPE</span><br></pre></td></tr></table></figure></p>
<p>类的属性命名<strong>必须</strong>遵循<strong>小写字母</strong>开头的驼峰式命名规范 ($camelCase)。<strong>必须</strong>对所有属性设置访问控制（如，<strong>public</strong>，<strong>protect</strong>，<strong>private</strong>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private $name;</span><br></pre></td></tr></table></figure></p>
<p>方法名称<strong>必须</strong>符合 camelCase() 式的<strong>小写字母</strong>开头驼峰命名规范。所有方法都<strong>必须</strong>设置访问控制（如，<strong>public</strong>，<strong>protect</strong>，<strong>private</strong>）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  public function fooBarBaz($storeName, $storeId, array $info = [])</span><br><span class="line">    &#123;</span><br><span class="line">        // method body</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>方法参数名称<strong>必须</strong>符合 camelCase 式的<strong>小写字母</strong>开头驼峰命名规范<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public function foo($storeName, $storeId, BazClass $bazObj, array $info = [])</span><br><span class="line">&#123;</span><br><span class="line">    // method body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-3-类注释"><a href="#7-3-类注释" class="headerlink" title="7.3 类注释"></a>7.3 类注释</h3><p>1）注释开始 /<strong> </strong>不可以<strong> /<em>，结束 </em>/ 不可以 </strong>/。<br>2）第二行开始描述，描述后一空行。<br>3）注解内容对齐，注解之间<strong>不可</strong>有空行。<br>4）星号和注释内容中间<strong>必须</strong>是一个空格。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我是类描述信息哦！</span><br><span class="line"> * </span><br><span class="line"> * @author  Author</span><br><span class="line"> * @since   2015年1月12日</span><br><span class="line"> * @version 1.0</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p>
<h3 id="7-4-属性注释"><a href="#7-4-属性注释" class="headerlink" title="7.4 属性注释"></a>7.4 属性注释</h3><p>1）注释开始 /<strong> </strong>不可以<strong> /<em>，结束 </em>/ </strong>不可以<strong> </strong>/。<br>2）星号和注释内容中间<strong>必须</strong>是一个空格。<br>3）使用var注解并注明类型。<br>4）注解基本类型包括int、sting、array、boolea、具体类名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">class Cache</span><br><span class="line">&#123;</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的键值</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">	public static $cacheKey = &apos;&apos;;</span><br><span class="line">	</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的键值</span><br><span class="line">     * @var string</span><br><span class="line">     */</span><br><span class="line">	public static $cacheTime = 60;</span><br><span class="line">	</span><br><span class="line">    /**</span><br><span class="line">     * 缓存的对象</span><br><span class="line">     * @var \CacheServer</span><br><span class="line">     */</span><br><span class="line">    public static $cacheObj = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div></header><footer class="post__foot u-cf"><ul class="post__tag u-fl"><li class="post__tag__item"><a class="post__tag__link" href="/tgroup/tags/开发规范/">开发规范</a></li></ul></footer></article></main><footer class="foot"><div class="foot-copy">&copy; 2018 - 2019 Tgroup</div></footer><script src="/tgroup/js/scroller.js"></script><script src="/tgroup/js/main.js"></script></body></html>